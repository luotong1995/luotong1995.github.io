<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[uwsgi]]></title>
    <url>%2F2019%2F04%2F26%2Fuwsgi%2F</url>
    <content type="text"></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯算法]]></title>
    <url>%2F2019%2F04%2F23%2Fbayes%2F</url>
    <content type="text"><![CDATA[贝叶斯公式先验概率后验概率公式]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[似然、概率、极大似然估计、先验概率、后验概率、最大后验概率]]></title>
    <url>%2F2019%2F04%2F23%2Flikelihood-and-probability-md%2F</url>
    <content type="text"><![CDATA[概率(Probability)概率是对随机变量发生的可能性的度量，是一个在[0-1]之间的实数，概率也是一有严格的定义的是符合柯尔莫哥洛夫定理的数学对象。可以参考wikipedia概率。 概率表示在给定$\theta$下随机变量$X=x$的可能性，可以用概率密度函数$f(x|\theta)$来表示，表示在给定$\theta$下$x$的概率密度，这里$x$表示随机变量$X$所取的值，即$X=x$。 似然(Likelihood)似然也叫做似然函数，似然函数的表达式为$L(\theta|x)$，也是一个条件概率或者条件分布的形式，似然函数表示在已知随机变量$X=x$的条件下，估计参数$\theta$的值，所以似然函数是一个关于$\theta$的函数。 概率和似然的联系概率和似然是对于概率密度函数的不同角度的描述，都是表示事件发生的概率。 假设$X$式离散随机变量，则其概率密度函数$f(x|\theta)$可以写为$f(x|\theta)=\mathbb{P}_{ \theta }\left( X=x \right)$，表示在参数$\theta$下随机变量$X$取到值$x$的可能性。如果发现L(\theta_1 | \textbf{x} ) = \mathbb{P}_{\theta_1}(\textbf{X} = \textbf{x}) > \mathbb{P}_{\theta_2}(\textbf{X} = \textbf{x}) = L(\theta_2 | \textbf{x}) 那么似然函数就得到如下推测：在参数$\theta_1$下随机向量$X$取到值$x$的可能性大于在参数$\theta_2$下随机向量$X$取到值$x$的可能性。换句话说，我们更有理由相信(相对于$\theta_2$来说)$\theta_1$，更有可能是真实值。(这里的可能性由概率来刻画) 如果$X$是连续的随机向量，那么其密度函数$f(x|\theta)$本身（如果在$x$连续的话）在$x$处的概率为0，为了方便考虑一维情况：给定一个充分小$\epsilon &gt; 0$，那么随机变量X取值在$(x - \epsilon, x + \epsilon)$区间内的概率即为: \mathbb{P}_\theta(x - \epsilon < X < x + \epsilon) = \int_{x - \epsilon}^{x + \epsilon} f(x | \theta) dx \approx 2 \epsilon f(x | \theta) = 2 \epsilon L(\theta | x)并且两个未知参数的情况下做比就能约掉$2\epsilon$，所以和离散情况下的理解一致，只是此时似然所表达的那种可能性和概率$f(x|\theta) = 0$无关。 综上，概率(密度)表达给定$\theta$下样本随机向量$X = x$的可能性，而似然表达了给定样本$X = x$下参数$\theta_1$(相对于另外的参数$\theta_2$)为真实值的可能性，由于该参数不是随机变量所以只能用可能性来描述，而不是用概率来描述。其实$L(\theta|\textbf{x})$和$f(\textbf{x}|\theta)$是对于事件从两种角度进行分析，都是表示的事件发生的概率。$f(\textbf{x}|\theta)$表示对于给定的$\theta$条件下，$x$出现的可能性是多大。而$L(\theta|\textbf{x})$表示在给定样本x的时候，哪个$\theta$使得$x$出现的可能性是多大。 极大似然估计(Maximum Likelihood Estimation, MLE)在统计学中，极大似然估计是一种估计统计模型参数的方法，意思就是根据样本数据估计模型参数的方法。按照字面意思就是找出参数$\theta$来似然函数$L(\theta|\textbf{x})$最大，其中使得其最大的参数$\hat {\theta}$就是极大似然估计，可以由如下表达式表示： {\displaystyle {\hat {\theta \,}}\in \{\underset {\theta \in \Theta }{\operatorname {arg\,max} }\ {\mathcal {L}}(\theta \,;x)\}}通常情况下对于使用对数似然进行求解，因为对数似然是一个严格递增函数 {\displaystyle \ell (\theta \,;x)=\ln {\mathcal {L}}(\theta \,;x)}求解过程假设$X$是独立同分布的数据，已知$X$的数据集大小为$m$，则似然函数可以有如下描述： L(\theta|x)=f(x|\theta)=f(x_1,x_2,...,x_m|\theta)=\prod _{ i=1 }^{ m }{f\left( X={ x }_{ i }|\theta\right)}使用对数似然进行求解，将乘积转化为求和 \log{L(\theta|x)}=\sum_{ i=1 }^{ m }{\log{f\left( X={ x }_{ i }|\theta\right)}}则极大似然估计为： {\displaystyle {\hat {\theta \,}}\in \{\underset {\theta \in \Theta }{\operatorname {arg\,max} }\ \log{L(\theta|x)}\}}=\{\underset {\theta \in \Theta }{\operatorname {arg\,max} }\sum_{ i=1 }^{ m }{\log{f\left( X={ x }_{ i }|\theta\right)}}\}极大似然估计举例说明例子假设袋子里面有若干个球，里面只有黑球和白球两种，从里面放回的依次取出来10次，其中出来的7次是黑球、3次是白球，那么认为袋子里面黑球的比例为0.7。这个参数是通过极大似然估计求出来的。其实这是一个典型的二项分布，并且已知部分样本数据，可以根据极大似然估计求出二项分布的参数。假设二项分布黑球的概率为$p$，则白球的概率为$1-p$，可以得到似然函数为： L(p|x)=\prod_{i=1}^{10}f\left(x_i|p\right)=p^7(1-p)^3使用对数似然求出使得似然函数最大的参数$p$： \log{L(p|x)}=\sum_{ i=1 }^{ 10 }{\log{f\left( X={ x }_{ i }|p\right)}}=7\log{p}+3\log{(1-p)}对上面表达式求导得到： L^{'}(p|x)=\frac { 7 }{ x } + \frac{3}{x-1}令倒数等于零得到参数$p=0.7$即为极大似然估计的值。 先验概率(Prior probability)先验概率就是根据现在目前的经验能够得到的最多的信息。下面举出两个例子作出解释。 投掷骰子比如说目前投掷一个骰子每一面向上的概率都是$\frac{1}{6}$，这就是一个先验证概率。 选水果假设目前有两个盒子，一个红色的，一个蓝色的，红色盒子中有2个苹果6个橘子，蓝色盒子中有3个苹果和1个橘子。现在假定我们随机选择一个盒子，从这个盒子中我们随机选择一个水果，观察一下选择了哪种水果，然后放回盒子中。假设我们重复这个过程很多次。假设我们在40%的时间中选择红盒子，在60%的时间中选择蓝盒子，并且我们选择盒子中的水果时是等可能选择的。 在这个例子中，我们要选择的盒子的颜色是一个随机变量，记作B。这个随机变量可以取两个值中的一个，即r(对应红盒子)或b(对应蓝盒子)。类似地，水果的种类也是一个随机变量，记作F。它可以取a(苹果)或者o(橘子)。我们把一个事件的概率定义为事件发生的次数与试验总数的比值，假设总试验次数趋于无穷，则$p(B= r)=\frac{4}{10} = \frac{2}{5}$和$p(B=b)=\frac{6}{10}=\frac{3}{5}$，现在有问题1:根据现在的条件如果选出的水果是橘子，那么这个水果最有可能出自于哪个盒子。 在这个问题中选择盒子的概率$p(B)$即为先验概率，因为这个是已经知道的，选择红色的和蓝色的盒子的概率就是已知的。 后验概率(Posterior probability)后验概率是事件已经发生，要求这个事件发生的原因是由某个因素引起的可能性的大小。 问题1中，在知道取出来的水果是橘子的时候，要求这个橘子是属于哪个盒子$p(B|F)$的时候就是在求一个后验概率，因为已经$F$事件已经发生。 最大后验概率估计(Maximum a Posteriori estimation，MAP)]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker安装配置及使用]]></title>
    <url>%2F2019%2F04%2F22%2Fdocker_install_and_use%2F</url>
    <content type="text"><![CDATA[Docker作为一个开源的应用容器引擎，已经在各个平台上进行了支持其中包括Linux、Mac、Windows、AWS和Azure。在正常使用的过程中都是基于Linux的，下面简单介绍一些在Linux上的安装和使用。 Docker安装配置Docker安装分为离线安装和在线安装，离线安装是基于二进制的方式进行安装。在线安装是根据不同的Linux环境进行安装。 离线安装如果需要在外网络环境下使用Docker，可以使用静态二进制文件进行安装，在需要进行升级的时候也使用二进制文件进行安装和升级。 首先下载Docker二进制文件进入如下网址选择自己想要的版本进行下载安装，Dokcer二进制文件下载地址，在本博客中选择的是18.06版本进行安装使用。1[root@host_name ～] wget https://download.docker.com/linux/static/stable/x86_64/docker-18.06.0-ce.tgz 安装Docker 解压上一步已经下载的Docker二进制文件 12# 解压二进制文件压缩包[root@host_name ～] tar xzvf docker-18.06.0-ce.tgz 将解压完成之后的可执行二进制文件拷贝到/usr/bin目录 12# 拷贝可运行的二进制文件到/usr/bin目录下[root@host_name ～] sudo cp docker/* /usr/bin 为Docker配置后台系统，在这里使用Linux的系统服务来完成Docker的后台启动 12# 添加Docker到system service, 添加docker.service文件[root@host_name ~] vim /usr/lib/systemd/system/docker.service 在docker.service文件中添加如下内容 123456789101112131415161718192021222324252627282930313233[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerdExecReload=/bin/kill -s HUP $MAINPID# Having non-zero Limit*s causes performance problems due to accounting overhead# in the kernel. We recommend using cgroups to do container-local accounting.LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity# Uncomment TasksMax if your systemd version supports it.# Only systemd 226 and above support this version.#TasksMax=infinityTimeoutStartSec=0# set delegate yes so that systemd does not reset the cgroups of docker containersDelegate=yes# kill only the docker process, not all processes in the cgroupKillMode=process# restart the docker process if it exits prematurelyRestart=on-failureStartLimitBurst=3StartLimitInterval=60s[Install]WantedBy=multi-user.target 启动Docker服务 12# 启动Docker[root@host_name ~] systemctl start docker.service 停止Docker服务 12# 停止Docker[root@host_name ~] systemctl stop docker.service 重启Docker服务 12# 重启Docker[root@host_name ~] systemctl restart docker.service 根据需要添加私有镜像库Docker私有镜像库是一个用来存储已经创建好的镜像的地方，Harbor是目前得到广泛使用的镜像库，接下来也会介绍一下Harbor的安装和使用。下面就是进行私有镜像库配置的过程。 修改docker启动文件, 可以根据需要添加镜像库的ip地址，下面的bash命令中的ip应改为已经存在的私有镜像库的ip地址 12[root@host_name ~] vim /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd --insecure-registry &lt;ip1&gt; --insecure-registry &lt;ip2&gt; 修改完成之后重新启动Docker 12[root@host_name ~] systemctl daemon-reload[root@host_name ~] systemctl restart docker.service 在线安装Docker的在线安装在不同平台下的Linux方式有所不同，Ubuntu、CentOS、Debian、Fedora，详细信息可以参考，Linux安装Docker，下面介绍一下Ubuntu的安装过程。 卸载老版本（如果存在）卸载老版本Docker1[root@host_name ~] sudo apt-get remove docker docker-engine docker.io containerd runc 设置Docker官方版本库 更新apt-get库 1[root@host_name ~] sudo apt-get update 安装设置版本库所需要的库 123456[root@host_name ~] sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common 添加Docker官方gpg 1[root@host_name ~] curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 设置Docker版本库 1234[root@host_name ~] sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 安装Docker12[root@host_name ~] sudo apt-get update[root@host_name ~] sudo apt-get install docker-ce 安装HarborHarbor是一个用于存储和分发Docker镜像的企业级Registry服务器，harbor的镜像存储使用的是官方的docker registry服务去完成，harbor的功能是在此之上提供用户权限管理、镜像复制等功能，提高使用的registry的效率，所以说Harbor给用户提供了用户权限管理、项目管理和镜像复制等功能。 安装docker-compose 下载docker-compose二进制文件 1[root@host_name ~] sudo curl -L "https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose 添加可执行权限 1[root@host_name ~] sudo chmod +x /usr/local/bin/docker-compose 下载Harbor并安装 下载Harbor离线安装文件 1[root@host_name ~] wget https://storage.googleapis.com/harbor-releases/release-1.6.0/harbor-offline-installer-v1.6.0.tgz 解压 1[root@host_name ~] tar xvf harbor-offline-installer-v1.6.0.tgz 修改Harbor配置文件 1234[root@host_name ~] vim harbor.cfg# 修改下面两项内容hostname = 9.111.215.134harbor_admin_password = Password 安装Harbor 12# --with-chartmuseum 是增加helm-chart的管理功能[root@host_name ~] sudo ./install.sh --with-chartmuseum Harbor使用命令 停止Harbor 12[root@host_name ~] docker-compose stop[root@host_name ~] docker-compose down -v 重启Harbor 1[root@host_name ~] docker-compose start 删除Harbor数据 12[root@host_name ~] rm -r /data/database[root@host_name ~] rm -r /data/registry Docker build]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Docker介绍]]></title>
    <url>%2F2019%2F04%2F22%2Fdocker%2F</url>
    <content type="text"><![CDATA[1. Docker介绍Docker是一个开源的应用容器引擎，由DotCloud开源的，可以让开发人员随意的将其应用打包到一个容器中。基于Docker的沙箱环境可以实现轻型隔离，多个容器间不会相互影响；Dokcer可以允许应用程序在笔记本电脑、内部服务器、公有云、私有云等上允许，Docker可以自动化打包和部署任何应用，方便地创建一个轻量级私有PaaS云，也可以用于搭建开发测试环境以及部署可扩展的web应用等。 2. Docker和VM对比Docker的实现原理是虚拟化，但是却不同于VM，VM是在宿主机上运行一个完成的操作系统，会占用很多CPU、内存、硬盘等资源。但是Docker不同于VM，Docker的运行只包含应用程序和运行程序的一些依赖库，基于容器机制运行在宿主机器上，容器将应用程序服务或功能与所有库，配置文件，依赖项和其他必要部分进行打包，能够在几秒钟完成启动。与VM相比，Docker的优势包括高效的应用程序开发，更低的资源使用和更快的部署。 VM 容器 应用程序需要操作系统的完整实例 应用程序与服务器共享操作系统，因此启动/关闭非常快 Hypervisor管理虚拟分区，有助于提高计算性能，但是它有些庞大 Docker守护程序使用Docker API或命令行监视和控制容器 通过管理程序执行运行的进程会导致开销 进程在服务器上以本机方式运行，从而实现低CPU /内存开销 3. Docker架构下面是一个使用Docker进行开发的架构图。 Docker Clinet(docker)，是允许使用REST API（http请求）在用户和Docker守护程序之间进行通信的接口。 Docker daemon(docker),在主机上运行，处理服务请求（例如，构建和存储映像，创建，运行和监视容器）。 Docker registry，是具有公共和私有访问权限的Docker容器映像的备份，是一个存储库，包括Harbor等。 Docker file，包含构建Docker镜像的说明，就是构建镜像的必要文件，也是主要依赖和编写的文件。 Docker image，是一个只读模板，其中包含用于创建Docker容器的指令/说明（当构建映像时，它将作为容器生效）。 Docker container，正在运行应用程序。可以有多个容器基于同一镜像运行。 可以使用Docker API或命令行创建，启动，停止，移动或删除。 同样重要的是要注意Docker使用以下操作系统功能： Namespace，命名空间确保在容器中运行的进程无法查看或影响在容器外部运行的进程。 Control Groups，用于资源管理和控制 UnionFS (FileSystem)，用于进行文件管理，是Linux中将不同的物理地址的目录挂载在一起的一种方法]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Conditional Random Fields论文阅读和理解]]></title>
    <url>%2F2019%2F04%2F22%2Fnlp_crf%2F</url>
    <content type="text"><![CDATA[CRF概率模型朴素贝叶斯朴素贝叶斯算法是一个用来分类的生成式模型，也可以说是一种概率模型。找出联合概率分布，然后通过贝叶斯公式求出后验概率。假设所有的特征是条件独立分布(conditionally independent)的，是一种生成式模型。 隐马尔可夫模型（Hidden Markov Model）， 联合概率分布（joint probability distribution.）指的是包含多个条件且所有条件同时成立的概率，记作P(X=a,Y=b)或P(a,b)，有的书上也习惯记作P(ab)，但是这种记法个人不太习惯，所以下文采用以逗号分隔的记法。 Maximum Entropy Model(最大熵模型)]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
</search>
